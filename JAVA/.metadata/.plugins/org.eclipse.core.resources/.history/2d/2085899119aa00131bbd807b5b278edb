package sorting2014;

@SuppressWarnings("rawtypes")
public class QuickSort implements Sorter {

	@Override
	public void sort(Comparable[] items, int cutoff) {

		if (items.length < 2) { // if the array has 1 item it is sorted
			return;
		}

		quicksort(items, 0, items.length - 1);

	}
	public int findMedian(Comparable[] items,
			int indexFirst,int indexMid,int indexLast) {
		if(items[indexFirst].compareTo(items[indexMid]) > 0 ) {
			
		} else {
			
		}
	}

	/**
	 * Sorts the element in array items. An item from the array is selected
	 * based on some criteria as a "pivot". The method works by finding the
	 * correct position of the pivot in the array.
	 * 
	 * The items that are less than the pivot are moved to the the left sub
	 * array. The items that are greater than the pivot are stored on the right
	 * of the pivot.
	 * 
	 * The last two steps do not assure that the the left or right sub arrays
	 * are sorted, but rather assure that the pivot element is in it's correct
	 * and final place. This means that the pivot position will change (although
	 * it might not).
	 * 
	 * After the pivot's correct position is found, a recursive call is
	 * performed to the right, and the left sub-arrays.
	 * 
	 * @param items
	 *            The (sub)array to be sorted
	 * @param first
	 *            the index of the first item in the (sub)array
	 * @param last
	 *            the index of the last item in the (sub)array
	 */
	public void quicksort(Comparable[] items, int first, int last) {

		int arrSize = last - first + 1; // determine the (sub)array's size

		if (arrSize < 2) {
			return; // if only one item in the array - it is sorted
		} 

		//int pivot = f irst + ((last - first) / 2); // the pivot index - the middle element
		
		
		int pivot = first + ((last - first) / 2); // the pivot index - the middle element
		
		pivot = parition(items, first, last, pivot); // moves the pivot to it's correct position 

		quicksort(items, first, pivot - 1); // recursively sort the sub array left from the pivot
		
		quicksort(items, pivot + 1, last); // recursively sort the sub array right from the pivot

	}

	/**
	 * A helper-method. Works by placing the pivot in it's correct position.
	 * 
	 * Elements with index lower than the pivot, are less than the pivot's
	 * value. Elements with index higher than the pivot , are greater than the
	 * pivot's value.
	 * 
	 * The last two statements DO NOT state that the left and right sub arrays
	 * are themselves sorted.
	 * 
	 * @return returns the updated index of the pivot
	 */
	private int parition(Comparable[] items, int left, int right, int pivotIndex) {

		swap(items, pivotIndex, left); // move the pivot out of the way

		int swap = left + 1; // set the initial swap position

		for (int i = swap; i <= right; i++) { // loop through swap until right(inclusive)

			if (items[left].compareTo(items[i]) > 0) { // compare the current item with the pivot

				swap(items, swap, i); // swap the current item with the swap position
				swap++; // move the swap position to the right
			}

		}
		swap(items, left, swap - 1); // put the pivot to it's right place
		return swap - 1; // swap - 1 is the pivot's new index

	}

	/**
	 * A helper-method. Swaps two elements from the array items. The integers
	 * indexFirst and indexSecond are the indexes of the elements to be swapped.
	 * 
	 * @param items
	 *            the array where the swap will occur
	 * @param indexFirst
	 *            the index of the first element
	 * @param secondSecond
	 *            the index of the second element
	 */
	private void swap(Comparable[] items, int indexFirst, int secondSecond) {

		Comparable temp = items[indexFirst]; // store the first in temporary variable

		items[indexFirst] = items[secondSecond]; // change the first to the second's value

		items[secondSecond] = temp; // change the second to the first's value

	}

}
